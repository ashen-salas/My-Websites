// Seguidor simple con 3 neuronas perceptron

//variables de pines
int S1 = 8;  //Sensor 1
int S2 = 4;  //Sensor 2
int S3 = 10; //Sensor 7 (obstaculos)

//Variables motores
//motor 1
int M1_IN1 = 3; 
int M1_IN2 = 5;
//motor 2
int M2_IN3 = 6; 
int M2_IN4 = 9;

//variables entradas
int L[3] = {0,0,0};

//pesos y polarizaciones
//perceptron 1
float W1[3] = {-2.0700, 0.5400, -2.3300 }; 
float b1 = 0.42;
//perceptron 2
float W2[3] = {0.2400, -2.4100, -2.3500 }; 
float b2 = 1.63;
//perceptron 3
float W3[3] = {-0.1000, -0.2100, 3.1100 };
float b3 = -0.63;

// Función hardlim (función escalón)
byte hardlim(float n) {
  return (n >= 0) ? 1 : 0;
}

void setup()
{
  //Entradas
  pinMode(S1, INPUT);
  pinMode(S2, INPUT);
  pinMode(S3, INPUT);
  //salidas
  //motor 1
  pinMode(M1_IN1, OUTPUT);
  pinMode(M1_IN2, OUTPUT);
  //motor 2
  pinMode(M2_IN3, OUTPUT);
  pinMode(M2_IN4, OUTPUT);

  Serial.begin(9600);
}

void loop()
{
  	//Lectura de variables de entrada
   L[0] = digitalRead(S1);
   L[1] = digitalRead(S2);
   L[2] = !digitalRead(S3);
  
  //perceptron 1
      // Calcula la suma ponderada 1
    float suma = 0;
    for (int j = 0; j < 3; j++) {
      suma += W1[j] * L[j];
    }
    suma += b1; // Añadir bias
  
  int P1 = hardlim(suma); // Salida perceptron 1
  
  //perceptron 2
  float suma2 = 0;
    for (int i = 0; i < 3; i++) {
      suma2 += W2[i] * L[i];
    }
    suma2 += b2; // Añadir bias
  int P2 = hardlim(suma2); // Salida perceptron 2

  //perceptron 3
      float suma3 = 0;
      for (int k = 0; k < 3; k++) {
        suma3 += W3[k] * L[k];
      }
      suma3 += b3; // Añadir bias
    
    int P3 = hardlim(suma3); // Salida perceptron 3
  
  //Salidas
  
  //Motor 1
  analogWrite(M1_IN1,45*P1);
  digitalWrite(M1_IN2,P3*P1);
  
  //Motor 2
  analogWrite(M2_IN3,45*P2);
  digitalWrite(M2_IN4,P3*P2);

}